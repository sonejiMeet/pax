


        to be FIXed


low-mid priority: replace function booleans (inside Ast_Declaration) to a single flag that have serialized value

mid-high priority: simplify this
    template <typename T>  // Temporary we want to simplify where this is used to get rid of this
    T* ast_static_cast(Ast* node, Ast_Type type) {
        return node->type == type ? static_cast<T*>(node) : nullptr;
    }

high priority: fix proper C output convertion for functions declared inside functions. Our parser and code_manager both resolve and infer correctly. Just find a way to output forward declarations in C code correctly.
EXAMPLE:

func :: (aa: ^int) -> int {
    func1 :: () -> float {  // this wont output proper C code yet
        printf("inside func1\n");
        return 1.0;
        func2 :: () -> int {
            return 224;
        }
        asodad := func2();
    }
}

// This kind of the idea on how function declarations inside other functions would look like from C's perspective.

int func2(){
}
float func1 () {
    printf("inside func1\n");
    return 1.0;
    int asodad = func2();
}
int func (int * aa) {
    float f = func1();
}



Mid-High priority: Fix floating point precision

mid priority: impliment struct

low-mid priority (not sure its a concern for now) reduce unnesessary allocation in our pool. peekNextToken() in lexer.cpp we could just pop the peeked token from our POOL after we check Token type and same for advance() in parser.cpp calls nextToken which obviously pushes the token into our pool.

low priority: ast_printer for printf does not work
low priority: inside struct Ast, should add filename member

when string literal removed it throws weird parsing error. ex.
s : string = "something; <----notice string literal missing
Parsing Error[18:9] Expected ';' after variable declaration. at token 'asda' (Type: TOK_IDENTIFIER)


(Todo for later)
Emit Debug Information
 \#line + debug info
emit #line directives so the compiler and debugger know the real source file and line.



DONE: fix not all control paths return a value
DONE: Mid-High priority: negative numbers can't be assigned yet
DONE: high priority: Fix return types mismatch. check if the function declaration has return type and whether the is_return statement exists in function declaration.

DONE:  add a way to not have to forward declare functions, If we encounter a function that isn't declared yet we could put it into a queue and come back to resolve it when we eventually find its declaration in the current scope

DONE: implement function defintion
DONE: high priority: fix pointers, https://jai.community/t/pointers/123/1

DONE: clean up port to linux code.
DONE: mid priority: make the c converter and compilation process automatic

DONE (replaced with ARRAY<> that uses our own POOL allocator): high priority: find an alternative to std::vector for Ast nodes
DONE (replaced with char * cause we already use pool alloc for them): high priority: get rid of std::string usage cause fuck c++ in the assshole

DONE: inside struct Ast, we are not setting line_number
DONE: floats are not lexed correctly there is unknown token for decimal





What should work?
- Comments ( //, /**/ )
- assignement operator for different types (both un/initialised (if time allows))
- types integer, float, string, bool, (including different sizes of types)
- struct (c style but slightly differnt)
- array using ( [] ) operators

- defer
- functions inside functions
- multiple function return values
- simple new operator that just does malloc, maybe its possible to 0 initialize by default (using calloc) and not if explicitly told by programmer.
- no need to forward declaring  functions/structs. it would be automatically done in .cpp
  -> If we encounter a function that isn't declared yet we could put it into a queue and come back to resolve it when we eventually find its declaration in the current scope

Check things for correctness and proof of concept
- should obey operator precedence (pemdas eg.)
- some simple programs like computing factorial, estimating arctan with taylor series or something (this could be hard)
-


things to implement
- code manager for error checking and outputing
- mylang to cpp converter



My philosophy when writing compiler

use inline functions to reduce overhead of control transfer (places a copy of function's code at each point where it is called at compile time)

no classes or modern c++ junk, just simple easy to read code


Why its will actually be a compiler and not just a stupid transpiler?

- we dont wanna be doing just minimal work (since we will be generating c code), its for losers. we want to actually make the compiler understand the syntax and manage errors (one way is proper type checking). so ideally there is should be no error from c compiler (if there is then it means our compiler has error!). we wanna be able to catch errors easily during lexer(throw error for unkown literals or tokens)/parsing/code_manager/and with good error messages.








What works?
Operator precedence is parsed correctly!
ex.

-------------------------
a:int=(1+2*3*4+5)/2;
b : int = (4 + 5) * 2;
c : int = 5 * 2 + 4;

num : int = a + 5;

s : string = "something";

if(a == b) {

    x : int;
}
-------------------------

OUTPUT

-------------------------

Program
    `-- StatementList
        |-- VarDecl ("a")
        |   |-- TypeSpecifier ("int")
        |   `-- BinaryExpr ("/")
        |       |-- ParenthesizedExpr
        |       |   `-- BinaryExpr ("+")
        |       |       |-- BinaryExpr ("+")
        |       |       |   |-- Number (1)
        |       |       |   `-- BinaryExpr ("*")
        |       |       |       |-- BinaryExpr ("*")
        |       |       |       |   |-- Number (2)
        |       |       |       |   `-- Number (3)
        |       |       |       `-- Number (4)
        |       |       `-- Number (5)
        |       `-- Number (2)
        |-- VarDecl ("b")
        |   |-- TypeSpecifier ("int")
        |   `-- BinaryExpr ("*")
        |       |-- ParenthesizedExpr
        |       |   `-- BinaryExpr ("+")
        |       |       |-- Number (4)
        |       |       `-- Number (5)
        |       `-- Number (2)
        |-- VarDecl ("c")
        |   |-- TypeSpecifier ("int")
        |   `-- BinaryExpr ("+")
        |       |-- BinaryExpr ("*")
        |       |   |-- Number (5)
        |       |   `-- Number (2)
        |       `-- Number (4)
        |-- VarDecl ("num")
        |   |-- TypeSpecifier ("int")
        |   `-- BinaryExpr ("+")
        |       |-- Identifier (a)
        |       `-- Number (5)
        |-- VarDecl ("s")
        |   |-- TypeSpecifier ("string")
        |   `-- String ("something")
        `-- IfStmt ("if")
            |-- BinaryExpr ("==")
            |   |-- Identifier (a)
            |   `-- Identifier (b)
            `-- BlockStmt
                `-- StatementList
                    `-- VarDecl ("x")
                        `-- TypeSpecifier ("int")

------------------------
