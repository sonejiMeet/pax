


        to be FIXed


reduce unnesessary allocation in our pool. peekNextToken() in lexer.cpp we could just pop the peeked token from our POOL after we check Token type and same for advance() in parser.cpp calls nextToken which obviously pushes the token into our pool.

low priority: ast_printer for printf does not work

low priority: inside struct Ast, should add filename member

when string literal removed it throws weird parsing error. ex.
s : string = "something; <----notice string literal missing
Parsing Error[18:9] Expected ';' after variable declaration. at token 'asda' (Type: TOK_IDENTIFIER)

struct
function defintion

(Todo for later)
Emit Debug Information
 \#line + debug info
emit #line directives so the compiler and debugger know the real source file and line.



DONE: mid priority: make the c converter and compilation process automatic

DONE (replaced with ARRAY<> that uses our own POOL allocator): high priority: find an alternative to std::vector for Ast nodes
DONE (replaced with char * cause we already use pool alloc for them): high priority: get rid of std::string usage cause fuck c++ in the assshole

DONE: inside struct Ast, we are not setting line_number
DONE: floats are not lexed correctly there is unknown token for decimal





What should work?
- Comments ( //, /**/ )
- assignement operator for different types (both un/initialised (if time allows))
- types integer, float, string, bool, (including different sizes of types)
- struct (c style but slightly differnt)
- array using ( [] ) operators

- defer
- functions inside functions
- multiple function return values
- simple new operator that just does malloc, maybe its possible to 0 initialize by default (using calloc) and not if explicitly told by programmer.
- no need to forward declaring  functions/structs. it would be automatically done in .cpp

Check things for correctness and proof of concept
- should obey operator precedence (pemdas eg.)
- some simple programs like computing factorial, estimating arctan with taylor series or something (this could be hard)
-


things to implement
- code manager for error checking and outputing
- mylang to cpp converter



My philosophy when writing compiler

use inline functions to reduce overhead of control transfer (places a copy of function's code at each point where it is called at compile time)

no classes or modern c++ junk, just simple easy to read code


Why its will actually be a compiler and not just a stupid transpiler?

- we dont wanna be doing just minimal work (since we will be generating c code), its for losers. we want to actually make the compiler understand the syntax and manage errors (one way is proper type checking). so ideally there is should be no error from c compiler (if there is then it means our compiler has error!). we wanna be able to catch errors easily during lexer(throw error for unkown literals or tokens)/parsing/code_manager/and with good error messages.








What works?
Operator precedence is parsed correctly!
ex.

-------------------------
a:int=(1+2*3*4+5)/2;
b : int = (4 + 5) * 2;
c : int = 5 * 2 + 4;

num : int = a + 5;

s : string = "something";

if(a == b) {

    x : int;
}
-------------------------

OUTPUT

-------------------------

Program
    `-- StatementList
        |-- VarDecl ("a")
        |   |-- TypeSpecifier ("int")
        |   `-- BinaryExpr ("/")
        |       |-- ParenthesizedExpr
        |       |   `-- BinaryExpr ("+")
        |       |       |-- BinaryExpr ("+")
        |       |       |   |-- Number (1)
        |       |       |   `-- BinaryExpr ("*")
        |       |       |       |-- BinaryExpr ("*")
        |       |       |       |   |-- Number (2)
        |       |       |       |   `-- Number (3)
        |       |       |       `-- Number (4)
        |       |       `-- Number (5)
        |       `-- Number (2)
        |-- VarDecl ("b")
        |   |-- TypeSpecifier ("int")
        |   `-- BinaryExpr ("*")
        |       |-- ParenthesizedExpr
        |       |   `-- BinaryExpr ("+")
        |       |       |-- Number (4)
        |       |       `-- Number (5)
        |       `-- Number (2)
        |-- VarDecl ("c")
        |   |-- TypeSpecifier ("int")
        |   `-- BinaryExpr ("+")
        |       |-- BinaryExpr ("*")
        |       |   |-- Number (5)
        |       |   `-- Number (2)
        |       `-- Number (4)
        |-- VarDecl ("num")
        |   |-- TypeSpecifier ("int")
        |   `-- BinaryExpr ("+")
        |       |-- Identifier (a)
        |       `-- Number (5)
        |-- VarDecl ("s")
        |   |-- TypeSpecifier ("string")
        |   `-- String ("something")
        `-- IfStmt ("if")
            |-- BinaryExpr ("==")
            |   |-- Identifier (a)
            |   `-- Identifier (b)
            `-- BlockStmt
                `-- StatementList
                    `-- VarDecl ("x")
                        `-- TypeSpecifier ("int")

------------------------
