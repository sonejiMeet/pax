
a := (1+2*3*4+5)/2;

b := 4 + 5 * 2;
c := 5 * 2 + 4;
d := 5 * 2 / 4;
e : float = 2/4 * 5;

h := 1;
num: int = 2 * (5 - h);

// single line comment

something := true;

/* multiline
  comment */

// more assosiativity tests
cc := (3 * 4 + 5) / 2;
dd := 6 / 3.0 + 2 * 7;
ee := 10 - 4 / 2 + 3 * 5;
ff := 1 + 2 * 3 - 4 / 5;
gg := (7 * 8 + 9) / (10 - 2);
hh : float = 5 * 2 + 3 * 4 / 2.0;

func1 :: () -> bool{
    f :int= -100;
    func(&f, a);
    if (f != 100) {
        f = 2;
        return true;
    }
    else {
        return false;
    }
}

main :: () {

    gamba: s8 = -129;
    fsdf: s16= 3;
    // bdfg: float64 = 1;
    bgiksd: float32 = 2.0000001;
    bgiksd1: = 2.0000001;


    printf("gamba = %d\n", gamba);

    { // testing pointer arithmetic
        a:int= 2;
        var:= &a;
        var2:= &var+1;
        printf("var = %x\n", &var);
        printf("var2 = %x\n", &var2);
    }

    vvv:= -2-4;

    {
        f: int = 100;
        printf("Address of f = %p\n", &f);

        // func(&f, a);
        af := func(&f, a);
        printf("f = %d\n", f);

        ret2 := func1();
        printf("af =  %d\n", af);
        if(ret2 == false) {
            printf("ret2 == false\n");
        }
        if(ret2 == true) {
            printf("ret2 == true\n");
        }
    }

    { // simple example of how to use pointers

        Name:= 100;
        printf("Name = %d\n", Name);

        Name2:= &Name;
        *Name2 = *Name2 * 420;
        printf("Name = %d\n", Name);

        Name3:= *Name2;
        printf("Name3 = %d\n", Name3);
    }

    {  // more complex example
        newline();

        aint: int = 5;
        aint = 10;
        printf("aint = %d\n", aint);
        printf("aint = %p\n", &aint);

        pInt : ^int = &aint; // ^int, val = addr of aint
        printf("pInt = %p\n", pInt); // should be equal to addr of aint

        // p_uninit_int := pInt; //
        p_uninit_int : ^int;
        p_uninit_int = pInt; // ^int, val of pInt
        printf("p_uninit_int = %d\n", *p_uninit_int);

        *p_uninit_int = 20; // dereference, so now aint = 20
        printf("p_uninit_int = %d\n", *p_uninit_int);
        printf("aint = %d\n", aint);

        rint: ^int = &aint; // reference to int, value = addr of a
        printf("rint = %p\n", rint);

        *rint = 30;      // dereference , so value of aint = 30
        printf("aint = %d\n", aint);

        *p_uninit_int = 40;
        printf("p_uninit_int = %d\n", *p_uninit_int);
        printf("aint = %d\n", aint);
    }

    { // testing pointer depths
        newline();

        what: int = 999;
        printf("what = %d\n", what);

        ligma: ^int = &what;   // reference of bruh
        *ligma = 68;        // store 42 at the location that ligma points to

        what1: int = *ligma;    // dereference ligma (get value at address ligma points to)
        printf("what1 = %d\n", what1);
        printf("what = %d\n", what);

        whatever : ^^int = &ligma;
        **whatever = 82;
        printf("what = %d\n", what);

        whatever2 : ^^^int = &whatever;
        ***whatever2 = **whatever;
        printf("what = %d\n", what);

        ***whatever2 = 96;
        printf("what = %d\n", what);

    }

    arrStaticInt: [4]int;
    // printf("arrStaticInt[0]", arrStaticInt[0]); // not working yet

/*
    { // test cases that should fail
        fail : int = 0;

        some : ^int = &fail;
        *some = 3.14; // fail because you can't store float number at ^int

        Fail_1: int = some;  // fail because type mismatch

        Fail_2: ^int = fail;  // also type mismatch

        Fail_3: int = *fail; // cannot dereference a non pointer type

    }
*/


    { // some tests with unary operators
        me:= 5;
        mee:= &me;
        meee : int = *mee**mee;
        printf("meee = %d\n", meee);

        m2 := &mee;
        m3 : int = **m2***m2;
        printf("m3 = %d\n", m3);

        printf("me = %p\n", &me);
        printf("mee = %p\n", mee);
        printf("m2 = %p\n", *m2);
    }

    printf("\n");

    v : int = 4;
    if (a != b) {
        x := 2223434243434334-094-0294.134354534574055;
        printf("x's value = %.8f\n", x);
        {
            block_inside_if := 3.1;
        }
        block_inside_if := 0;
    }
    else {
        printf("a == b\n");
    }
    printf("a=%d\n",a);
    printf("b=%d\n",b);
    printf("c=%d\n",c);
    printf("d=%d\n",d);
    printf("e=%f\n",e);
    printf("h=%d\n",h);

    scopedint := 5.0;
    scopedint = 2.0;
    printf("scopedint=%f\n",scopedint);

    zeroChild: int = 0;
    {
        g := 5;
        g = 3;
        firstChild := 0;
        firstChild = 22;
        {
            secondChild := 0;
            secondChild = 335;
        }
    }

    idk = 293824;
    printf("\nidk = %d\n", idk);

    boolean = false;
    printf("\n");
}

idk : int = 1;

boolean: bool = true;


func :: (aa: ^int, sssd: int) -> int {

    // func1 :: () -> float {  // this wont output proper C code yet
    //     printf("inside func1\n");
    //     return 1.0;

    //     func2 :: () -> int {
    //         return 224;
    //     }

    //     asodad := func2();

    // }
    printf("Address of aa = %p\n", aa);
    something := *aa * 2;

    *aa = 699;
    ss : ^int = aa;
    printf("Address of ss = %p\n", ss);

    *ss = *ss + 2;
    return something;
}

newline :: (){
    printf("\n");
}

