
// assfdfdf : s64;
a := (1+2*3*4+5)/2;

b := 4 + 5 * 2;
c := 5 * 2 + 4;
d := 5 * 2 / 4;
e : float = 2/4 * 5;

h := 1;
num: int = 2 * (5 - h);

// single line comment

something := true;

/* multiline
  comment */


// structName :: struct {

// }

// func :: (aa: ^int) -> int;
cc := (3 * 4 + 5) / 2.0;
dd : float = 6 / 3.0 + 2 * 7;
ee : float = 10 - 4 / 2.0 + 3 * 5;
ff : float = 1 + 2 * 3 - 4.0 / 5;
gg : float = (7 * 8 + 9) / (10 - 2.0);
hh :float = 5 * 2 + 3 * 4 / 2.0;

func1 :: () -> bool{
    f :int= -100;
    func(&f, a);
    printf("f inside func1 is equal to: %d\n", f);
    printf("f inside func1 is equal to: %p\n", &f);
    if(f != 100) {
        f = 2;
        return true;
    }
    else {
        return false;
    }
    //
    // return true;
}


main :: () {

    numa := -2;
    printf("numa= %d\n", numa);
    printf("cc =%f\n",cc );
    printf("dd =%f\n",dd );
    printf("ee =%f\n",ee );
    printf("ff =%f\n", ff);
    printf("gg =%f\n",gg );
    printf("hh =%f\n", hh);

    {
        f :int= 100;
        printf("Address of f = %p\n", &f);

        af := func(&f, a);

        ret2 := func1();
        printf("f = %d\n", f);
        printf("af =  %d\n", af);
        if(ret2 == false) {
            printf("ret2 == false\n");
        }
        if(ret2 == true) {
            printf("ret2 == true\n");
        }
    }

    { // simple example of how to use pointers
        bruh: int = 333;

        ligma: ^int = &bruh;   // reference of bruh
        *ligma = 420;        // store 42 at the location that ligma points to

        what: int = *ligma;    // dereference ligma (get value at address ligma points to)
        printf("what = %d\n", what);
        printf("bruh = %d\n", bruh);
    }

    {  // more complex example
        printf("\n");

        aint: int = 5;
        aint = 10;
        printf("aint = %d\n", aint);
        printf("aint = %p\n", &aint);

        pInt : ^int = &aint; // ^int, val = addr of aint
        printf("pInt = %p\n", pInt); // should be equal to addr of aint

        // p_uninit_int := pInt; //
        p_uninit_int : ^int;
        p_uninit_int = pInt; // ^int, val of pInt
        printf("p_uninit_int = %d\n", *p_uninit_int);

        *p_uninit_int = 20; // dereference, so now aint = 20
        printf("p_uninit_int = %d\n", *p_uninit_int);
        printf("aint = %d\n", aint);

        rint: ^int = &aint; // reference to int, value = addr of a
        printf("rint = %p\n", rint);

        *rint = 30;      // dereference , so value of aint = 30
        printf("aint = %d\n", aint);


        *p_uninit_int = 40;
        printf("p_uninit_int = %d\n", *p_uninit_int);
        printf("aint = %d\n", aint);
    }

    { // pointer depths
        printf("\n");
        what: int = 999;
        printf("what = %d\n", what);

        ligma: ^int = &what;   // reference of bruh
        *ligma = 68;        // store 42 at the location that ligma points to

        what1: int = *ligma;    // dereference ligma (get value at address ligma points to)
        printf("what1 = %d\n", what1);
        printf("what = %d\n", what);

        whatever : ^^int = &ligma;
        **whatever = 82;
        printf("what = %d\n", what);

        whatever2 : ^^^int = &whatever;
        ***whatever2 = **whatever;
        printf("what = %d\n", what);

        ***whatever2 = 96;
        printf("what = %d\n", what);

    }

    arrStaticInt: [4]int;
    // printf("arrStaticInt[0]", arrStaticInt[0]); // not working yet

/*
    { // test cases that should fail
        fail : int = 0;

        some : ^int = &fail;
        *some = 3.14; // fail because you can't store float number at ^int

        Fail_1: int = some;  // fail because type mismatch

        Fail_2: ^int = fail;  // also type mismatch

        Fail_3: int = *fail; // cannot dereference a non pointer type

        my_pointer: ^int;
        *my_pointer = 47;  // and cannot dereference uninitialized pointer


    }
*/


    { // some tests with unary operators
        me:= 5;
        mee:= &me;
        meee : int = *mee**mee;
        printf("meee = %d\n", meee);

        m2 := &mee;
        m3 : int = **m2+**m2;
        printf("m3 = %d\n", m3);

        printf("me = %p\n", &me);
        printf("mee = %p\n", mee);
        printf("m2 = %p\n", *m2);
    }

    printf("\n");

    v : int = 4;
    if (a != b) {
        x : float = 2334.34;
        printf("x's value = %f\n", x);
        {
            block_inside_if := 3.1;
        }
        block_inside_if := 0;
    }
    else {
        printf("a == b\n");
    }
    printf("a=%d\n",a);
    printf("b=%d\n",b);
    printf("c=%d\n",c);
    printf("d=%d\n",d);
    printf("e=%f\n",e);
    printf("h=%d\n",h);

    scopedint := 5.0;
    scopedint = 2.0;
    printf("scopedint=%f\n",scopedint);

    zeroChild: int = 0;
    {
        g := 5;
        g = 3;
        firstChild := 0;
        firstChild = 22;
        {
            secondChild := 0;
            secondChild = 335;
        }
    }

    idk = 293824;
    printf("\nidk = %d\n", idk);

    boolean = false;
    printf("\n");
}

idk : int = 1;

boolean: bool = true;


func :: (aa: ^int, sssd: int) -> int {

    // func1 :: () -> float {  // this wont output proper C code yet
    //     printf("inside func1\n");
    //     return 1.0;

    //     func2 :: () -> int {
    //         return 224;
    //     }

    //     asodad := func2();

    // }
    printf("Address of aa = %p\n", aa);
    something := *aa * 2;

    *aa = 699;
    ss : ^int = aa;
    printf("Address of ss = %p\n", ss);

    *ss = *ss + 2;
    return something;
}

